<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=zh-Hans:300,300italic,400,400italic,700,700italic|zh-Hans:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="javascript," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="JavaScript 模块化编程*前言The Moudle Pattern,模块模式，也译为模组模式，是一种通用的对代码进行模块化组织与定义的方式。Modules是指实现某一特定功能的一组方法和代码。许多现代语言都定义了模块化的组织方式，比如Golang和java,他们都使用package与import来管理和使用模块，而目前版本的javascript并未提供一种原生的、语言级别的模块化组织模式，">
<meta property="og:type" content="article">
<meta property="og:title" content="javaScript模块化编程">
<meta property="og:url" content="http://yoursite.com/2014/09/24/javaScript模块化编程/index.html">
<meta property="og:site_name" content="Muzipan's  Blog">
<meta property="og:description" content="JavaScript 模块化编程*前言The Moudle Pattern,模块模式，也译为模组模式，是一种通用的对代码进行模块化组织与定义的方式。Modules是指实现某一特定功能的一组方法和代码。许多现代语言都定义了模块化的组织方式，比如Golang和java,他们都使用package与import来管理和使用模块，而目前版本的javascript并未提供一种原生的、语言级别的模块化组织模式，">
<meta property="og:updated_time" content="2016-11-19T08:20:58.333Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="javaScript模块化编程">
<meta name="twitter:description" content="JavaScript 模块化编程*前言The Moudle Pattern,模块模式，也译为模组模式，是一种通用的对代码进行模块化组织与定义的方式。Modules是指实现某一特定功能的一组方法和代码。许多现代语言都定义了模块化的组织方式，比如Golang和java,他们都使用package与import来管理和使用模块，而目前版本的javascript并未提供一种原生的、语言级别的模块化组织模式，">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2014/09/24/javaScript模块化编程/"/>

  <title> javaScript模块化编程 | Muzipan's  Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Muzipan's  Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-globe"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-list"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heart"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-reorder"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-key"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                javaScript模块化编程
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-09-24T15:43:35+08:00" content="2014-09-24">
              2014-09-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="JavaScript-模块化编程"><a href="#JavaScript-模块化编程" class="headerlink" title="JavaScript 模块化编程"></a>JavaScript 模块化编程</h3><p>*前言<br>The Moudle Pattern,模块模式，也译为模组模式，是一种通用的对代码进行模块化组织与定义的方式。Modules是指实现某一特定功能的一组方法和代码。许多现代语言都定义了模块化的组织方式，比如Golang和java,他们都使用package与import来管理和使用模块，而目前版本的javascript并未提供一种原生的、语言级别的模块化组织模式，而是将模块化方法交由开发者实现。因此，出现了很多种javaScript模块化的实现方式，比如，CommonJS Moudles、AMD等等。<br>以AMD为例，该规范使用fefine函数来定义模块。使用AMD规范进行模块化编程是很简单的，大致上的结构是这样的：</p>
<pre><code>define(factory(){
 // 模块代码
 // return something;
});
</code></pre><p>目前尚在制定中的Harmony/ECMAScript6，会对模块化做出语言级别的定义，但距离实用尚 遥不可及，这里暂不讨论它。<br>模块模式其实一直伴随着Javascript存在，最近我需要重构自己的一些代码，因此我参考和总结了一些实用的模块化编程实践，以便更好的组织我的代码。<br>注：本文并不关心模块如何载入，只关心现金该如何组织模块化代码。还有，不必纠结于所谓的模式，真正重要的是模块代码及思想。所谓模式，不是我们 书写代码的一些技巧和经验的总结，是一些惯用法，实践中应灵活运用。</p>
<h4 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h4><h5 id="闭包与IIFE-Immediately-Invoked-Function-Expression"><a href="#闭包与IIFE-Immediately-Invoked-Function-Expression" class="headerlink" title="闭包与IIFE(Immediately-Invoked Function Expression)"></a>闭包与IIFE(Immediately-Invoked Function Expression)</h5><p>模块模式使用了JavaScript的一个特性，即闭包。现金流行的一些JS库中经常见到以下形式的代码：</p>
<pre><code>;(function(参数){
   //模块代码
   //return something;
 })(参数)；
</code></pre><p> 上面代码定义了一个匿名函数，并立即调用自己，这叫做自调用匿名函数(SIAF),更准确一点，称为立即调用的函数表达(Immediately-Invoked Function Expression, IIFE–读做“iffy”)。</p>
<blockquote>
<p>在闭包中可以定义私有变量和函数，外部无法访问它们，从而做到了私有成员的隐藏和隔离。而通过返回对象或函数，或是将某对象作为参数传入，在函数内对该对象进行操作，就可以公开我们所希望对外暴露的公开方法与数据。<code>这其实就是模块化的本质。</code></p>
</blockquote>
<p>注1：上面的代码中，最后的一对括号是对匿名函数的调用，因此必不可少。而前面的一对围绕着函数表达式的一对括号并不是必需的，但它可以用来给开发人员一个指示 – 这是一个 IIFE。也有一些开发者在函数表达式前面加上一个惊叹号（!）或分号（;)，而不是用括号包起来。比如 knockoutjs 的源码大致就是这样的：</p>
<pre><code>!function (参数) {
   // 代码
   // return something
 }(参数);
</code></pre><p>还有些人喜欢用括号将整个 IIFE 围起来，这样就变成了以下的形式：</p>
<pre><code>(function (参数) {
  // 代码
  // return something
}(参数));
</code></pre><p> 注2：在有些人的代码中，将 undefined 作为上面代码中的一个参数，他们那样做是因为 undefined 并不是 JavaScript 的保留字，用户也可以定义它，这样，当判断某个值是否是 undefined 的时候，判断可能会是错误的。将 undefined 作为一个参数传入，是希望代码能按预期那样运行。不过我认为，一般情况下那样做并没太大意义。</p>
<h4 id="参数输入"><a href="#参数输入" class="headerlink" title="参数输入"></a>参数输入</h4><p>JavaScript 有一个特性叫做隐式全局变量（implied globals），当使用一个变量名时，JavaScript 解释器将反向遍历作用域链来查找变量的声明，如果没有找到，就假定该变量是全局变量。这种特性使得我们可以在闭包里随处引用全局变量，比如 jQuery 或 window。然而，这是一种不好的方式。<br>考虑模块的独立性和封装，对其它对象的引用应该通过参数来引入。如果模块内需要使用其它全局对象，应该将这些对象作为参数来显式引用它们，而非在模块内直接引用这些对象的名字。以 jQuery 为例，若在参数中没有输入 jQuery 对象就在模块内直接引用 $ 这个对象，是有出错的可能的。正确的方式大致应该是这样的： </p>
<pre><code>;(function (q, w) {
  // q is jQuery
  // w is window
  // 局部变量及代码
  // 返回
})(jQuery, window);
</code></pre><p>相比隐式全局变量，将引用的对象作为参数，使它们得以和函数内的其它局部变量区分开来。这样做还有个好处，我们可以给那些全局对象起一个别名，比如上例中的 “q”。现在看看你的代码，是否没有经过对 jQuery 的引用就到处都是”$”？ </p>
<h4 id="模块输出"><a href="#模块输出" class="headerlink" title="模块输出"></a>模块输出</h4><p>有时我们不只是要使用全局变量，我们也要声明和输出模块中的对象，这可以通过匿名函数的 return 语句来达成，而这也构成了一个完整的模块模式。来看一个完整的例子： </p>
<pre><code>var MODULE = (function () {
    var my = {},
    privateVariable = 1;

    function privateMethod() {
        // ...
    }
    my.moduleProperty = 1;
    my.moduleMethod = function () {
        // ...
    };
    return my;
}());
</code></pre><p> 这段代码声明了一个变量 MODULE，它带有两个可访问的属性：moduleProperty 和 moduleMethod，其它的代码都封装在闭包中保持着私有状态。参考以前提过的参数输入，我们还可以通过参数引用其它全局变量。 </p>
<h4 id="输出简单的对象"><a href="#输出简单的对象" class="headerlink" title="输出简单的对象"></a>输出简单的对象</h4><p> 很多时候我们都能见到这样的模块化代码：</p>
<pre><code>var Module1 = (function () {
   var private_variable = 1;
   function private_method() { /*...*/ }

   var my = {
      property1: 1,
      property2: private_variable,
      method1: private_method,
      method2: function () {// ..... 
      }
   };
   return my;
}());
</code></pre><p>另外，对于简单的模块化代码，若不涉及私有成员等，其实也可以直接使用对象直接量来表达一个模块： </p>
<pre><code>var Widget1 = {
  name: &quot;who am i?&quot;,
  settings: {
    x: 0,
    y: 0
  },
  call_me: function () {
    // ...
  }
};
</code></pre><h4 id="输出函数"><a href="#输出函数" class="headerlink" title="输出函数"></a>输出函数</h4><p>有时候我们希望返回的并不是一个对象，而是一个函数。有两种需求要求我们返回一个函数，一种情况是我们需要它是一个函数，比如 jQuery，它是一个函数而不是一个简单对象；另一种情况是我们需要的是一个“类”而不是一个直接量，之后我们可以用 “new” 来实例它。目前版本的 JavaScript 并没有专门的“类”定义，但它却可以通过 function 来表达。 </p>
<pre><code>var Cat = (function () {
  // 私有成员及代码 ...

  return function(name) {
    this.name = name;
    this.bark = function() { /*...*/ }
  };
}());

var tomcat = new Cat(&quot;Tom&quot;);
tomcat.bark();
</code></pre><p> 为什么不直接定义一个 function 而要把它放在闭包里呢？简单点的情况，确实不需要使用 IIFE 这种形式，但复杂点的情况，在构造我们所需要的函数或是“类”时，若需要定义一些私有的函数，就有必要使用 IIFE 这种形式了。</p>
<p>另外，在 ECMAScript 第五版中，提出了 Object.create() 方法。这时可以将一个对象视作“类”，并使用 Object.create() 进行实例化，不需使用 “new”。 </p>
<h4 id="Revealing-Module-Pattern"><a href="#Revealing-Module-Pattern" class="headerlink" title="Revealing Module Pattern"></a>Revealing Module Pattern</h4><p>前面已经提到一种形式是输出对象直接量（Object Literal Notation），而 Revealing Module Pattern 其实就是这种形式，只是做了一些限定。这种模式要求在私有范围内中定义变量和函数，然后返回一个匿名对象，在该对象中指定要公开的成员。参见下面的代码： </p>
<pre><code>var MODULE = (function () {
  // 私有变量及函数
  var x = 1;
  function f1() {}
  function f2() {}

  return {
    public_method1: f1,
    public_method2: f2
  };
}());
</code></pre><h3 id="模块模式的变化"><a href="#模块模式的变化" class="headerlink" title="模块模式的变化"></a>模块模式的变化</h3><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>上面的举例都是在一个地方定义模块，如果我们需要在数个文件中分别编写一个模块的不同部分该怎么办呢？或者说，如果我们需要对已有的模块作出扩展该怎么办呢？其实也很简单，将模块对象作为参数输入，扩展后再返回自己就可以了。比如：</p>
<pre><code>var MODULE = (function (my) 
var MODULE = (function () {
  // 私有变量及函数
  var x = 1;
  function f1() {}
  function f2() {}

  return {
    public_method1: f1,
    public_method2: f2
  };
}());
</code></pre><p> 上面的代码为对象 MODULE 增加了一个 “anotherMethod” 方法。</p>
<h4 id="松耦合扩展（Loose-Augmentation）"><a href="#松耦合扩展（Loose-Augmentation）" class="headerlink" title="松耦合扩展（Loose Augmentation）"></a>松耦合扩展（Loose Augmentation）</h4><p>上面的代码要求 MODULE 对象是已经定义过的。如果这个模块的各个组成部分并没有加载顺序要求的话，其实可以允许输入的参数为空对象，那么我们将上例中的参数由 MODULE 改为 MODULE || {} 就可以了：</p>
<pre><code>var MODULE = (function (my) {
 // add capabilities...
  return my;
}(MODULE || {}));
</code></pre><h4 id="紧耦合扩展（Tight-Augmentation）"><a href="#紧耦合扩展（Tight-Augmentation）" class="headerlink" title="紧耦合扩展（Tight Augmentation）"></a>紧耦合扩展（Tight Augmentation）</h4><p>与上例不同，有时我们要求在扩展时调用以前已被定义的方法，这也有可能被用于覆盖已有的方法。这时，对模块的定义顺序是有要求的。 </p>
<pre><code>var MODULE = (function (my) {
  var old_moduleMethod = my.moduleMethod;

  my.moduleMethod = function () {
    // 方法重载
    // 可通过 old_moduleMethod 调用以前的方法...
  };

  return my;
}(MODULE));
</code></pre><h4 id="克隆与继承（Cloning-and-Inheritance）"><a href="#克隆与继承（Cloning-and-Inheritance）" class="headerlink" title="克隆与继承（Cloning and Inheritance）"></a>克隆与继承（Cloning and Inheritance）</h4><pre><code>var MODULE_TWO = (function (old) {
    var my = {},
        key;

    for (key in old) {
        if (old.hasOwnProperty(key)) {
            my[key] = old[key];
        }
    }

    var super_moduleMethod = old.moduleMethod;
    my.moduleMethod = function () {
        // override method on the clone, access to super through super_moduleMethod
    };

    return my;
}(MODULE));
</code></pre><p>有时我们需要复制和继承原对象，上面的代码演示了这种操作，但未必完美。如果你可以使用 Object.create() 的话，请使用 Object.create() 来改写上面的代码： </p>
<pre><code>var MODULE_TWO = (function (old) {
  var my = Object.create(old);

  var super_moduleMethod = old.moduleMethod;
  my.moduleMethod = function () {
    // override method ...
  };

  return my;
}(MODULE));
</code></pre><h3 id="子模块（Sub-modules）"><a href="#子模块（Sub-modules）" class="headerlink" title="子模块（Sub-modules）"></a>子模块（Sub-modules）</h3><p>模块对象当然可以再包含子模块，形如 MODULE.Sub=(function(){}()) 之类，这里不再展开叙述了。</p>
<h4 id="各种形式的混合"><a href="#各种形式的混合" class="headerlink" title="各种形式的混合"></a>各种形式的混合</h4><p>以上介绍了常见的几种模块化形式，实际应用中有可能是这些形式的混合体。比如： </p>
<pre><code>var UTIL = (function (parent, $) {
    var my = parent.ajax = parent.ajax || {};

    my.get = function (url, params, callback) {
        // ok, so I&apos;m cheating a bit :)
        return $.getJSON(url, params, callback);
    };

    // etc...
    return parent;
}(UTIL || {}, jQuery));
</code></pre><h3 id="与其它模块规范或-JS-库的适配"><a href="#与其它模块规范或-JS-库的适配" class="headerlink" title="与其它模块规范或 JS 库的适配"></a>与其它模块规范或 JS 库的适配</h3><h4 id="模块环境探测"><a href="#模块环境探测" class="headerlink" title="模块环境探测"></a>模块环境探测</h4><p>现今，CommonJS Modules 与 AMD 有着广泛的应用，如果确定 AMD 的 define 是可用的，我们当然可以使用 define 来编写模块化的代码。然而，我们不能假定我们的代码必然运行于 AMD 环境下。有没有办法可以让我们的代码既兼容于 CommonJS Modules 或 AMD 规范，又能在一般环境下运行呢？</p>
<p>其实我们只需要在某个地方加上对 CommonJS Modules 与 AMD 的探测并根据探测结果来“注册”自己就可以了，以上那些模块模式仍然有用。</p>
<p>AMD 定义了 define 函数，我们可以使用 typeof 探测该函数是否已定义。若要更严格一点，可以继续判断 define.amd 是否有定义。另外，SeaJS 也使用了 define 函数，但和 AMD 的 define 又不太一样。</p>
<p>对于 CommonJS，可以检查 exports 或是 module.exports 是否有定义。</p>
<p>现在，我写一个比较直白的例子来展示这个过程：</p>
<pre><code>var MODULE = (function () {
  var my = {};
  // 代码 ...

  if (typeof define == &apos;function&apos;) {
    define( function(){ return my; } );
  }else if (typeof module != &apos;undefined&apos; &amp;&amp; module.exports) {
    module.exports = my;
  }
  return my;
}()); 
</code></pre><p> 上面的代码在返回 my 对象之前，先检测自己是否是运行在 AMD 环境之中（检测 define 函数是否有定义），如果是，就使用 define 来定义模块，否则，继续检测是否运行于 CommonJS 中，比如 NodeJS，如果是，则将 my 赋值给 module.exports。因此，这段代码应该可以同时运行于 AMD、CommonJS 以及一般的环境之中。另外，我们的这种写法应该也可在 SeaJS 中正确执行。</p>
<h3 id="其它一些-JS-库的做法"><a href="#其它一些-JS-库的做法" class="headerlink" title="其它一些 JS 库的做法"></a>其它一些 JS 库的做法</h3><p>现在许多 JS 库都加入了对 AMD 或 CommonJS Modules 的适应，比如 jQuery, Mustache, doT, Juicer 等。</p>
<p>jQuery 的写法可参考 exports.js:</p>
<pre><code>if ( typeof module === &quot;object&quot; &amp;&amp; module &amp;&amp; typeof module.exports === &quot;object&quot; ) {
    module.exports = jQuery;
} else {
    if ( typeof define === &quot;function&quot; &amp;&amp; define.amd ) {
        define( &quot;jquery&quot;, [], function () { return jQuery; } );
    }
}

if ( typeof window === &quot;object&quot; &amp;&amp; typeof window.document === &quot;object&quot; ) {
    window.jQuery = window.$ = jQuery;
}
</code></pre><p> 与前面我写的那段代码有些不同，在对 AMD 和 CommonJS 探测之后，它将 jQuery 注册成了 window 对象的成员。</p>
<p>然而，jQuery 是一个浏览器端的 JS 库，它那样写当然没问题。但如果我们所写的是一个通用的库，就不应使用 window 对象了，而应该使用全局对象，而这一般可以使用 this 来得到。</p>
<p>我们看看 Mustache 是怎么做的： </p>
<pre><code>(function (root, factory) {
  if (typeof exports === &quot;object&quot; &amp;&amp; exports) {
    factory(exports); // CommonJS
  } else {
    var mustache = {};
    factory(mustache);
    if (typeof define === &quot;function&quot; &amp;&amp; define.amd{
      define(mustache); // AMD
    } else {
      root.Mustache = mustache; // &lt;script&gt;
    }
  }
}(this, function (mustache) {
  // 模块主要的代码放在这儿
});
</code></pre><p> 这段代码与前面介绍的方式不太一样，它使用了两个匿名函数。后面那个函数可以看作是模块代码的工厂函数，它是模块的主体部分。前面那个函数对运行环境进行检测，根据检测的结果对模块的工厂函数进行调用。另外，作为一个通用库，它并没使用 window 对象，而是使用了 this，因为在简单的函数调用中，this 其实就是全局对象。</p>
<p>再看看 doT 的做法。doT 的做法与 Mustache 不同，而是更接近于我在前面介绍 AMD 环境探测的那段代码： </p>
<pre><code>(function() {
    &quot;use strict&quot;;

    var doT = {
        version: &apos;1.0.0&apos;,
        templateSettings: { /*...*/ },
        template: undefined, //fn, compile template
        compile:  undefined  //fn, for express
    };

    if (typeof module !== &apos;undefined&apos; &amp;&amp; module.exports) {
        module.exports = doT;
    } else if (typeof define === &apos;function&apos; &amp;&amp; define.amd) {
        define(function(){return doT;});
    } else {
        (function(){ return this || (0,eval)(&apos;this&apos;); }()).doT = doT;
    }
    // ...
}());
</code></pre><p>这段代码里的 (0, eval)(‘this’) 是一个小技巧，这个表达式用来得到 Global 对象，’this’ 其实是传递给 eval 的参数，但由于 eval 是经由 (0, eval) 这个表达式间接得到的，因此 eval 将会在全局对象作用域中查找 this，结果得到的是全局对象。若是代码运行于浏览器中，那么得到的其实是 window 对象。</p>
<p>其实也有其它办法来获取全局对象的，比如，使用函数的 call 或 apply，但不给参数，或是传入 null： </p>
<pre><code>var global_object = (function(){ return this; }).call();
</code></pre><p>你可以参考这篇文章：<a href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html" target="_blank" rel="external"> Javascript的this用法</a></p>
<p>Juicer 则没有检测 AMD，它使用了如下的语句来检测 CommonJS Modules： </p>
<pre><code>typeof(module) !== &apos;undefined&apos; &amp;&amp; module.exports ? module.exports = juicer : this.juicer = juicer;
</code></pre><p>另外，你还可以参考一下这个： <a href="https://gist.github.com/kitcambridge/1251221" target="_blank" rel="external">https://gist.github.com/kitcambridge/1251221</a></p>
<pre><code>(function (root, Library) {
  // The square bracket notation is used to avoid property munging by the Closure Compiler.
  if (typeof define == &quot;function&quot; &amp;&amp; typeof define[&quot;amd&quot;] == &quot;object&quot; &amp;&amp; define[&quot;amd&quot;]) {
    // Export for asynchronous module loaders (e.g., RequireJS, `curl.js`).
    define([&quot;exports&quot;], Library);
  } else {
    // Export for CommonJS environments, web browsers, and JavaScript engines.
    Library = Library(typeof exports == &quot;object&quot; &amp;&amp; exports || (root[&quot;Library&quot;] = {
      &quot;noConflict&quot;: (function (original) {
        function noConflict() {
          root[&quot;Library&quot;] = original;
          // `noConflict` can&apos;t be invoked more than once.
          delete Library.noConflict;
          return Library;
        }
        return noConflict;
      })(root[&quot;Library&quot;])
    }));
  }
})(this, function (exports) {
  // ...
  return exports;
});
</code></pre><p>我觉得这个写得有些复杂了，我也未必需要我的库带有 noConflict 方法。不过，它也可以是个不错的参考。 </p>
<h4 id="JavaScript-模块化的未来"><a href="#JavaScript-模块化的未来" class="headerlink" title="JavaScript 模块化的未来"></a>JavaScript 模块化的未来</h4><p>未来的模块化方案会是什么样的？我不知道，但不管将来如何演化，作为一种模式，模块模式是不会过时和消失的。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/javascript/" rel="tag">#javascript</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2014/09/22/数组去重/" rel="next" title="数组去重">
                <i class="fa fa-chevron-left"></i> 数组去重
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/02/10/iframe 根据内容自适应高度/" rel="prev" title="iframe 根据内容自适应高度">
                iframe 根据内容自适应高度 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/img/史迪奇.gif"
               alt="lilyone" />
          <p class="site-author-name" itemprop="name">lilyone</p>
          <p class="site-description motion-element" itemprop="description">hello kitty</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/lilyone" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github-alt"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/5792353400/profile?topnav=1&wvr=6" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://my.csdn.net/" target="_blank" title="CSDN">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  CSDN
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://macshuo.com/" title="MacTalk" target="_blank">MacTalk</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://example.com/" title="Title" target="_blank">Title</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript-模块化编程"><span class="nav-number">1.</span> <span class="nav-text">JavaScript 模块化编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模块模式"><span class="nav-number">1.1.</span> <span class="nav-text">模块模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#闭包与IIFE-Immediately-Invoked-Function-Expression"><span class="nav-number">1.1.1.</span> <span class="nav-text">闭包与IIFE(Immediately-Invoked Function Expression)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参数输入"><span class="nav-number">1.2.</span> <span class="nav-text">参数输入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模块输出"><span class="nav-number">1.3.</span> <span class="nav-text">模块输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#输出简单的对象"><span class="nav-number">1.4.</span> <span class="nav-text">输出简单的对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#输出函数"><span class="nav-number">1.5.</span> <span class="nav-text">输出函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Revealing-Module-Pattern"><span class="nav-number">1.6.</span> <span class="nav-text">Revealing Module Pattern</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模块模式的变化"><span class="nav-number">2.</span> <span class="nav-text">模块模式的变化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#扩展"><span class="nav-number">2.1.</span> <span class="nav-text">扩展</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#松耦合扩展（Loose-Augmentation）"><span class="nav-number">2.2.</span> <span class="nav-text">松耦合扩展（Loose Augmentation）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#紧耦合扩展（Tight-Augmentation）"><span class="nav-number">2.3.</span> <span class="nav-text">紧耦合扩展（Tight Augmentation）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#克隆与继承（Cloning-and-Inheritance）"><span class="nav-number">2.4.</span> <span class="nav-text">克隆与继承（Cloning and Inheritance）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子模块（Sub-modules）"><span class="nav-number">3.</span> <span class="nav-text">子模块（Sub-modules）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#各种形式的混合"><span class="nav-number">3.1.</span> <span class="nav-text">各种形式的混合</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#与其它模块规范或-JS-库的适配"><span class="nav-number">4.</span> <span class="nav-text">与其它模块规范或 JS 库的适配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模块环境探测"><span class="nav-number">4.1.</span> <span class="nav-text">模块环境探测</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其它一些-JS-库的做法"><span class="nav-number">5.</span> <span class="nav-text">其它一些 JS 库的做法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JavaScript-模块化的未来"><span class="nav-number">5.1.</span> <span class="nav-text">JavaScript 模块化的未来</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2013 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lilyone</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
